# Evaluation

- **Status:** Accepted
- **Application Document:** https://github.com/w3f/Grants-Program/blob/master/applications/openbrush-follow-up-2.md
- **Milestone:** 6
- **Previously successfully merged evaluation:** all by cruikshankss

**Deliverables** (ALL ACCEPTED)

| Number | Deliverable                                                | Link                                                                                                                                                                                                                                        | Notes                                                                                                                                                                                                                                                                                                       |
|--------|------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b.    | Documentation                                              | [Documentation about upgradeable contracts](https://docs.openbrush.io/smart-contracts/upgradeable)                                                                                                                                          | The documentation describes how storage works in upgradeable contracts and contains suggestions on not corrupting the storage. OpenBrush provides primitives to develop upgradeable contracts, and documentation also includes examples of how to use them.                                                 | 
| 1.     | Implement `delegate_call` in contract-pallet               | [Implementation in substrate](https://github.com/paritytech/substrate/pull/10617), [fix of the bug](https://github.com/paritytech/substrate/pull/11771)                                                                                     | Implemented `seal_delegate_call` works in the same way as [delegatecall](https://docs.soliditylang.org/en/v0.8.10/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries) in ethereum. It allows the execution of the foreign code in the context of the current contract.                | 
| 2.     | Implement `set_code_hash` in contract-pallet               | [Implementation in substrate](https://github.com/paritytech/substrate/pull/10690)                                                                                                                                                           | Implemented `set_code_hash` allows replacing the code of the current contract with another code. It is a new approach to simplify the deployment of upgradable contracts that follow the `Proxy` pattern and reduce gas consumption.                                                                        | 
| 3.     | Import `delegate_call` in ink! and update `Proxy` example  | [Implementation in ink!](https://github.com/paritytech/ink/pull/1133)                                                                                                                                                                       | To have a more consistent API with common `seal_call`, we did refactoring of `CallBuilder` and related stuff to support delegate and common calls in user-friendly form.                                                                                                                                    | 
| 4.     | Implement `Diamond` Standard in OpenBrush with ink!        | [Initial implementation](https://github.com/Supercolony-net/openbrush-contracts/pull/93), [Refactored](https://github.com/Supercolony-net/openbrush-contracts/pull/137)                                                                     | Initially, we implemented the `Diamond` standard as in [EIP](https://eips.ethereum.org/EIPS/eip-2535). But after, we refactored it to take less size and simplified API. With release `v2.2.0` it uses new storage and is ready for upcoming storage refactoring in ink!.                                   | 
| 5.     | Implement `Diamond` Standard on raw Rust without ink!      | [Rust implementation](https://github.com/Supercolony-net/openbrush-contracts/pull/153)                                                                                                                                                      | We implemented the same contractor ink and on rust. The rust version still uses ink! primitives but without ink! code generation. It takes less space for ~1.2 kb. We plan to use it as a base for upcoming optimization to ink!.                                                                           | 
| 6.     | Create an upgradable analog of each  contract in OpenBrush | [New macro](https://github.com/Supercolony-net/openbrush-contracts/blob/d6e29f05fd462e4e027de1f2f9177d594a5a0f05/lang/macro/src/lib.rs#L447), [Refactoring with new macro](https://github.com/Supercolony-net/openbrush-contracts/pull/137) | We introduced a new `openbrush::upgradeable_storage` macro to OpenBrush. Macro allows making any data type upgradable(more about it in the documentation). We annotated all data types provided by OpenBrush with that macro. All storages are logic units now and are upgradeable by default in OpenBrush. | 
| 7a.    | Marketing - Write down article about OpenBrush             | [Article](https://medium.com/supercolony/deep-dive-into-openbrush-dc04d5cc7825)                                                                                                                                                                                                             | The article describes features of Open Brush with use cases - "Deep dive into OpenBrush"                                                                                                                                                                                                                                              | 
| 7b.    | Marketing - Create 2 educational video for OpenBrush       | [First Video](https://www.youtube.com/watch?v=rlROrqbYPeE) [Second Video](https://www.youtube.com/watch?v=eo_cY8lVNes)                                                                                                                      | The first video is general overview what is OpenBrush and it describes available features. The second describes of how to write upgradeable contracts and what is it.                                                                                                                                       | 

## General Notes

Please note: Supercolony delivered this M6 before M5, because M5 depends on the timing of external code review, etc.

Firstly, thank you for focusing on documentation, standards for ink! and a great developer experience (DX) in this extremely complex substrate ecosystem. I think your work is all extremely valuable and important & thank you for completing this M6 work with such a high standard of ideals. 

Great work & thank you for implementing the Proxy, Diamond and set_code_hash upgradability patterns. In general, I agree that upgradeability is a feature rather than a bug, even if smart contracts are immutable by default. References in Rust are immutable by default, but of course there is an art to working with mutable refs as well as the dark arts of unsafe Rust. ;-) And in general, if blockchain is the first form of digital life (e.g. the RNA or DNA), then perhaps smart contracts are like the methylation/epigenetics, and must theoretically evolve & upgrade as well. ;-) 

That being said, it is extremely critical that your work holds the standard of being cryptographically secure to protect Layer 0, so please keep us updated if you potentially need maintenance grants/treasury funding to further refactor, simplify and secure the OpenBrush codebase (including Rust, auditing, networking, cryptography, Layer 0, whatever else is required, etc.). 

I'm very excited your long-term vision is to support raw Rust contracts for wasm devs. I think that's a very idealistic vision to strive for and that you have a great roadmap to get there.

Thanks for your examples of contracts on GitHub, as well as the fantastic lectures from WasmConf, Polkadot Decoded (great demo), excellent article, and your truly excellent & exemplary documentation site. 

I really appreciate that you've taken care to create declarative modifiers (e.g. access to minting), since the declarative paradigm seems more secure/functional/mathematical/abstract than imperative/OOP. I believe it provides more security naturally due to the way state is managed. I also find it really secure that your constructors can be empty (with no state) thanks to your abstraction via macros. 

I find it really interesting how you've described the grey area between chain extensions and smart contracts, regarding where the storage is handled (on-chain or off-chain), although I would love to learn more from you in the future regarding this! It's interesting how you describe contracts as a "sandbox" (similar to a secure VM) because they can simply be reverted on error, but do note that true security will include gas metering and monitoring potential bottlenecks how collators/validators provide/execute the wasm. I'm interested going forward on more of your theory on how to prevent crashing the storage. This is certainly a complex ecosystem! ;-)

Good luck with implementing XCM in M7 to enable custom contracts between parachains (great job with the wrapper macro already)! It seems like with that work, OpenBrush will cover so many/(all?) of the core features of ink!/substrate!

Thanks for carefully collecting/monitoring the ideals of cosmos SDK, solidity developer ecosystem, and Astar/Phala/Moonbeam/Acala and using these to build towards all ideals in the substrate ecosystem.

To match the extremely high quality of your docs, I humbly suggest a few grammatical edits for your article:
- change "on Rust" to "in Rust" in a couple of places
- `set_ode_hash` to *`set_code_hash`
- add a `.` after "Open Brush includes over 25 contract default implementations"

You do mention "with the support of W3F" in your article, which--as far as I know--adheres to our PR guidelines, and I plan to connect you with Grants PR in case you need further assistance with retweeting, PR, etc.

Congratulations & thank you again for completing this milestone!
